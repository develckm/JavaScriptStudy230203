<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>var 의 호이스팅 현상</title>
</head>
<body>
    <h1>var 의 호이스팅 현상</h1>
    <p>hoisting 은 끌어올린다는 의미로 var 이 지역에 선언되어도
        전역에서 사용되는 현상을 의미한다.</p>
    <p>var 변수는 전역의 필드인 window 에 선언되기 때문에 scope 가 없고 무조건 전역에 호출된다.</p>
    <p>오류는 아니지 지역변수가 없는 것은 프로그래밍의 한계를 만들 수 있기 때문에 let 을 만들었다.</p>

<script>
    var a=10;
    {
        var a=20;
        console.log("지역의 a:"+a); //20
    }
    console.log("전체의 a:"+a) //10
    //지역변수 a와 전역변수 a가 독립적이라면 전역의 a가 10이어야 하는데 20이 된다.
    //지역에서 선언했는데 전역의 변수가 바뀐다고 해서 hosting 현상이라 한다. -> 오류로 취급 ???
    let b=10;
    {
        let b=20;
        console.log("지역의 b:"+b);
    }
    console.log("전역의 b:"+b)
    //java는 함수 안에서 부모영역에 선언한 변수 이름을 자식 영역에서 사용할 수 없다. (필드는 예외)

    //var 윈도우의 필드로 변수를 선언하는 명령어기 때문에 hoisting 현상이 발생한다.
    //window (전역) : 브라우저 객체로 js가 실행될때 브라우저와 관련된 모든 필드를 포함하는 최상위 객체로 생성
    //window.document : 브라우저에서 불러온 html 문서를 객체로 생성하는 것
    //window.document.(node 개체) : html 에 작성된 태그를 객체로 생성한 것 (node : 가지에 달린 무언가)
    //DOMTree : HTML 에 작성된 태그를 tree 의 형상으로 구성하는 것 (tag -> node)
    console.log(window);
    console.log(window.document)
    //var a=10; window 필드로 a가 선언되었기 때문에 a는 무조건 전역이다. -> 오류가 아니다.
    console.log(window.a);

    window.c=100;//==var c=100;
    {
        window.c=10;//==var c=10;
    }
    console.log("c :"+c);
</script>

</body>
</html>