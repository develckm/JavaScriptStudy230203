<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Object 와 자료형</title>
</head>
<body>
    <h1>자바스크립트의 자료형들</h1>
    <p>자료형(참조형) 데이터 : 복수의 데이터를 참조하는 것을 의미(프로그래밍에서 객체를 의미)</p>
    <h2>자바스크립트의 Object</h2>
    <ul>
        <li>Object : 모든 프로토타입의 부모 타입(js는 프로토타입 언어)</li>
        <li>프로토타입 언어 : 타입(함수)을 명시하면 프로토타입(생성자가 명시됨)이 생성되고 객체 생성시 프로토 타입을 참조(객체지향 언어와 크게 다르지 않다.)</li>
        <li>new 연산자 : 프로토타입의 명시된 생성자를 호출해서 객체를 만들어 반환한다. </li>
        <li>new Object() == {} : 객체 생성을 리터럴하게 할 수 있다.</li>
        <li>js는 함수가 타입이 되기 때문에 함수를 명시하면 프로토 타입이 생성된다.(타입과 함수(실행의 모음)의 구분이 없다.)</li>
    </ul>
    <h2>객체지향 언어와 프로토타입 언어(함수형 언어)의 차이 </h2>
    <ul>
        <li> class 를 객체의 타입으로 사용한다. <-> 프로토 타입을 타입으로 사용  </li>
        <li> 상속은 부모의 필드를 물려받고 재정의 할 수 있다. <-> 부모 프로토타입을 링크로 사용할 수 있다. </li>
        <li> class 는 오직 타입이다. <-> 프로토타입은 객체처럼 생성되어 있다.</li>
        <li> 함수가 타입될 수 없다 <-> 함수가 타입이 된다. (매개변수로 함수를 사용할 수 있고 함수를 변수가 참조할 수도 있다.)</li>
    </ul>

<script>
function Person(name,age){ //타입로 사용될 함수는 파스칼 규칙을 사용
    this.name=name; //this : 객체의 필드 접근자 (js는 필드 정의할 때도 사용됨)
    this.age=age;
    //type 은 new 연산자 호출시 객체를 반환하다록 이미 명시되 있어서 return 을 작성할 수 없다.
}

console.log(Person) //코드가 출력
console.log(Person.prototype) //함수를 명시하면 프로토타입을 생성한다.
const p=new Person("경민",38);
console.log(p)
console.log(p.__proto__) //객체의 타입
console.log(p.__proto__.__proto__) //객체의 타입의 부모타입 (Object의 프로토타입)

function sum(a,b){ //연산의 집합으로 사용되는 함수는 낙타표기법을 사용
    return a+b;
}
console.log(sum);
console.log(sum.prototype);
console.log(sum(10.33,2.55))
</script>



</body>
</html>